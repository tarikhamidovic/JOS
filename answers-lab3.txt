1. What is the purpose of having an individual handler function for each 
exception/interrupt? (i.e., if all exceptions/interrupts were delivered to 
the same handler, what feature that exists in the current implementation could
not be provided?)

Svaki exception/interupt zahtijeva svoj handler jer tretman za svaki od njih
razlicit. Da imamo samo jedan handler, ne bismo ih mogli razlikovati.


2. Did you have to do anything to make the user/softint program behave correctly? 
The grade script expects it to produce a general protection fault (trap 13), 
but softint's code says int $14. Why should this produce interrupt vector 13? 
What happens if the kernel actually allows softint's int $14 instruction to invoke
the kernel's page fault handler (which is interrupt vector 14)?

User program pokusava da trigeruje trap 14 za koji nema ovlastenje.
Ova operacija trigeruje interupt 13. U slucaju da user program moze 
pozvati interupt 14, moguce je da dodje do alokacije stranica za koje
user nema ovlastenje.


3.The break point test case will either generate a break point exception or 
a general protection fault depending on how you initialized the break 
point entry in the IDT (i.e., your call to SETGATE from trap_init). Why?
How do you need to set it up in order to get the breakpoint exception to 
work as specified above and what incorrect setup would cause it to trigger 
a general protection fault? 

DPL za break point gate u IDT-u je setovan na 0, sto znaci da
samo kernel ima privilegije da ga poziva. U slucaju da ga user pozove, 
desiti ce se General protection fault, tako da moramo DPL od gate-a
za break point setovati na 3 da bi ga user mogao pozivati.


4. What do you think is the point of these mechanisms, particularly 
in light of what the user/softint test program does?

Razlog za ovaj mehanizam je da user ne moze natjerati kernel da izvrsava
handlere za koje nema potrebe, ovim se user ogranicava i ne dozvoljava mu
se da izvrsava neke maliciozne stvari.
